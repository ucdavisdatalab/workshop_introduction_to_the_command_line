[["index.html", "Introduction to the Unix Command Line Overview", " Introduction to the Unix Command Line Tyler Shoemaker Carl Stahmer 2021-09-15 Overview Learn and practice how to talk directly to your computer via the command line. The Unix shell is a powerful tool for using scientific software, working with large datasets, and controlling remote servers. It is primarily used to manage files and run programs, and it allows for automation of repetitive tasks. This workshop is a prerequisite for many of DataLab’s workshops, including Introduction to Version Control with Git, Reproducible Research for Teams with GitHub, and the Remote Computing series. "],["preliminaries.html", "1 Preliminaries 1.1 Interactive Session Information 1.2 About this Reader 1.3 Objectives for this Workshop 1.4 Prerequisites", " 1 Preliminaries This workshop covers the basics of using the Unix command line interface. It is a hybrid workshop. First, independently work through this online tutorial at your own pace. Next, join us for the live interactive session (details below), during which we will learn to interact with the files and file structures of our computers in new ways. 1.1 Interactive Session Information The workshop includes a live, interactive session, to be held via Zoom on Thursday, November 4th from 12-2pm. Zoom login information will be sent to all registered participants via email; reach out to datalab-training@ucdavis.edu the day prior if you received a registration confirmation but have not received your Zoom link. 1.2 About this Reader This reader provides background information that will help participants to better understand the concepts introduced during the interactive session. It also includes information to help you successfully install software for the workshop, which must be completed prior to the interactive session (note: software setup is only necessary for Windows users). 1.3 Objectives for this Workshop By the end of the workshop, learners should be able to: Explain the directory structure of their computers Navigate across and within files and directories Create, copy, and delete files Use command line tools to edit files Identify where to go for help and to learn more 1.4 Prerequisites No prior coding experience is required for this workshop. Participants should have a computer with a Unix shell scripting program (Terminal, Bash, etc.) installed and the latest version of Zoom. Windows users will need to install a Unix terminal ahead of the session. Instructions for doing so are on the following page. "],["installing-a-command-line-interface.html", "2 Installing a Command Line Interface 2.1 PROGRAM 2.2 PROGRAM INSTALLATION INSTRUCTIONS", " 2 Installing a Command Line Interface The following instructions are for Windows users only. Mac and Linux both come pre-installed with command line interfaces, whereas Windows does not. Interested to know why? This article offers a nice overview of the history of different operating systems. 2.1 PROGRAM 2.2 PROGRAM INSTALLATION INSTRUCTIONS "],["working-with-the-command-line.html", "3 Working with the Command Line 3.1 The Anatomy of the Command Line 3.2 Interacting with the Command Line 3.3 Command Syntax 3.4 Stopping a Command 3.5 Common Command Line Commands", " 3 Working with the Command Line Most people interact with their computer through a graphical user interface, or GUI, which allows them to use a mouse, keyboard, and graphical elements on screen (such as file menus, pictures of folders and files, etc.) as they do their work. We tend to conflate our operating systems and their GUIs because computer hardware and software manufacturers tightly pack these two things together as a convenience to users. But the operating system that makes your computer work (Windows 10, Mac Big Sur, etc.) and the GUI that you interact with are, in fact, completely different and separable software packages; it is possible to use different methods/software to interact with your computer than the stock GUI that launches automatically when you turn it on. On such method is the “command line” interface. The command line offers a text-only, non-graphical means of interacting with your computer, acting somewhat like a typewriter (rather than a window or desktop, as the prevailing metaphors for GUIs go). In the early days of computing, all user interaction with your computer happened at the command line. But during the 1980s, computer manufacturers—with Apple at the lead—made a big push to convert their machines to the windowing systems we know today. The command line, they felt, was too difficult for users to understand and this, in turn, would hamper computer sales. Nowadays, there are few viable (and at present, almost no commercially available) GUIs that can compete with the predominant systems of Macs and PCs. While this is not the case for Linux machines, people are by and large locked into the GUIs that come pre-installed on their machines. Command line interfaces are, however, available, and some are even still installed on popular computer hardware. Using these interfaces require you to launch a special program. Mac users will use an application called “Terminal,” which ships by default on macOS. To launch Terminal, go to: Applications -&gt; Utilities -&gt; Terminal When you launch the application, you will see something like this: Windows users will use an application called PROGRAM. Instructions for installing this program are on the previous page. To launch PROGRAM, go to: Click on the Windows Start Menu and search for “PROGRAM” Alternatively, Click on the Windows Start Menu, select Programs, and browse to PROGRAM When you launch the application, you will see something like this: 3.1 The Anatomy of the Command Line While the command line can look intimidating to those raised on a GUI, using it is actually quite simple. Instead of pointing and clicking on things to make them happen, you type in your commands. Let’s return to the window that opens when you start Terminal or PROGRAM. Here, we see the command line prompt. You’ll enter your commands here. But before doing so, let’s point out some valuable information contained within the prompt itself. The beginning of the line, tshoe@ds, tells us the current user (tshoe) and current computer (ds). This may seem redundant, but with the command line it is possible to interact with remote computers via a network, so it’s helpful to have this information displayed as a reference point. The bit of information after the colon (in this example, the ~ character) tells us where in the computer’s filesystem we are. We’ll discuss this later. For now, just keep in mind that you can look here to find your current location. In this case, ~ means you are in your home directory. After the location, we see the $ character. It is an indicator that lets you know the command line application is waiting for you to enter something. (Note that you do not need to type this character, it will appear automatically, but the examples below include it to emulate what you’ll see onscreen) Depending on your system and/or command line interface, you may or may not also see a solid or flashing box that appears after the prompt character. This is a cursor position indicator and it tells you where the current cursor is in the terminal. This is useful if you need to go back and correct and error. Generally speaking, you can’t click around with a mouse in this kind of interface. Instead, you’ll use your computer’s Left and Right arrows to move the cursor to the correct location and make any changes from there. 3.2 Interacting with the Command Line As noted earlier, we interact with the command line by typing in our commands. For example: $ echo …will print back to screen any text that you supply to the command. It literally echoes your text: $ echo &quot;Hello world!&quot; Hello world! $ To execute this, or any command, you simply hit the Return/Enter key on your keyboard. You’ll see that when you execute a command, the system will perform the indicated operation, print any output from that operation to screen, and deliver a new command line prompt. Note that depending on your particular system and/or command line interface, things might look slightly different on your computer. However, the basic presentation and function as described above will be the same. 3.3 Command Syntax The syntax of commands is relatively straightforward. Commands use a space to delimit their different components, and you can add optional flags to modify how a command runs (more on these flags below). When put together, these components look like so: $ [command] [optional flags] [file, data, or other pointer on which to run the command] There is one caveat to this: because commands use spaces to delimit their components, you can run into problems when running commands on files with spaces in their names. Your command line interface program will interpret that file’s spaces as separate components and an error will almost surely result. If you’re running a command on a file with a space in its name, you’ll need to escape that space with \\. This will throw an error: $ [command] file name.txt This will not: $ [command] file\\ name.txt 3.4 Stopping a Command Did you do something that causes your computer to print a million lines on screen? Did you decide you don’t want that file copied to a new location, and it’s still in the midst of transferring? You can interrupt any command with CTRL+C. This will stop whatever current process is running in your interface. While you can stop a command, for the most part it isn’t possible to undo a command. Please take care to know exactly what you’re running and what you’re running it on, especially when it comes to modifying or deleting things on your computer. 3.5 Common Command Line Commands During our hands-on workshop session we will practice using several commands. Be prepared to have this page ready as a reference during class to make things easier. Table 3.1: Command Command Name Function ls List Lists all files in the current directory. ls -l List with Long flag Lists additional information about each file. ls -a List with All flag Lists all files, including hidden files. pwd Print Working Directory Prints the current working directory. mkdir Make Directory Creates a new file directory. cd Change Directory Navigates to another directory on the file system. mv Move Moves files. cp Copy Copies files. rm Remove/delete Deletes files. man Manual Opens the manual page for another command. For a more complete list of Unix Commands, see the Unix Cheat Sheet. "],["file-paths.html", "4 File Paths 4.1 Path Hierarchies 4.2 Absolute vs. Relative Paths", " 4 File Paths Due to the nature of its stripped down display, the command line interface can at times feel a bit static. But it offers much of the same functionality that modern GUIs offer, including the ability to move around your computer. With GUIs, we tend to navigate with our mouses; on the command line, we’ll use our keyboard. The live workshop session will cover this in depth, but for now it’s important to have a working sense of how your files are structured. Your computer uses a directory structure to organize all of your files. This structure is like a map of all the places you can navigate to. Each file has an address on this map, and there is a path that leads to it. When you use a GUI, your computer does the work of determining which path to follow to find the file or folder you’d like to open, but performing the same operation with the command line interface requires us to manually specify where we’d like to go. We do this with the following syntax: /this/is/a/path/to/your/file.txt This is called a file path. 4.1 Path Hierarchies Importantly, the structure of your computer’s directory is hierarchical. Directories nest inside one another, and you need to have a sense of which directories are “above” or “below” the present file path to navigate with the command line interface. The top-most directory in your computer is called root. Unix systems denote it with the / character. It’s like the trunk of a tree: every directory in your computer branches off from it. A complication arises from the fact that directories can also branch off from each other. Whenever you make a folder within another folder—or a subdirectory—you’ve created another branch in the tree, one which is at the same time a branch of root and a branch of whatever directory you’re currently in. For example, this is the structure of the practice exercise we’ll be using during our live session: . top of the directory ├── instructions.md file in the top of the directory ├── instructions.pdf &quot;&quot; └── level_1 first subdirectory ├── level_2a a second subdirectory, below level_1 │ ├── 2.txt file in the second subdirectory │ └── extra_file.txt &quot;&quot; ├── level_2b another subdirectory, at the same level as level_2a │ └── level_3 third subdirectory, below level_2a and level_2b │ └── 1.txt file in the third subdirectory └── wrong_name.txt file in first subdirectory As you can see, this can get complicated! When you’re first getting started with the command line, it’s easy to feel a little lost and forget where you are in your computer. We’ll discuss some strategies to help with this in the live session, but know for the moment that the pwd command will always tell you where you are relative to root: $ pwd /here/is/where/you/are/located/in/your/computer 4.2 Absolute vs. Relative Paths The path above begins with /, which, remember, is root. When you see a path that begins with /, it’s showing you the full, or absolute location of a directory or file. No matter where you are in your computer, no matter how deep into a series of subdirectories you may be, if you used this absolute path with a navigation command, you could go straight to the location it indicates. By contrast, a relative path is context-specific. It depends on wherever you are in your computer. Unix uses some shorthand for this: . denotes the current location in your computer, while .. denotes the directory above that location. We can use this shorthand to avoid having to type out the entire path to a file or directory (this is useful if you’re far away from root). To continue with the example from above, if you’re at computer: /here/is/where/you/are/located/in/your/computer ^^^^^^^^ And you want to get to located: /here/is/where/you/are/located/in/your/computer ^^^^^^^ You could use an absolute path to get there, which would be: /here/is/where/you/are/located Or, you could use a relative path: ../../../ This would take you three directories up from computer, which, as you can see above, is located (count the names between backslashes). That’s much shorter, but there’s a downside: those .. sequences are pretty hard to read without context, and it’s easy to get confused. Clearly, there can sometimes be a trade-off between using absolute and relative paths. "],["text-editing-with-the-command-line.html", "5 Text Editing with the Command Line 5.1 Accessing Command Line Text Editors 5.2 Basic Vim Commands", " 5 Text Editing with the Command Line Beyond the basic commands and navigation functions we’ve discussed so far, the command line also features the ability to edit files directly, usually by means of a text editor. These editors are similar in nature to Microsoft Word or Mac Pages but they’re much more stripped down and tend to work best with plain text files (.txt files, code files like .R or .py, etc.). These editors are only accessible from the command line and it is important to know how to use them so that you can open, read, and write directly in the command line window. 5.1 Accessing Command Line Text Editors Macs and PROGRAM both ship with a text editor called Vim (other common editors include Emacs and Nano). To open a file with vim, type vi in a command line window, followed by the file name. If you want to create a new file, simply type the file name you’d like to use for that file after vi. Vim works a bit differently than other text editors and word processors. It has a number of ‘modes,’ which provide different forms of interaction with a file’s data. We will focus on two modes, Normal mode and Insert. When you open a file with Vim, the program starts in Normal mode. This mode is command-based and, somewhat strangely, it doesn’t let you insert text directly in the document (the reasons for this have to do with Vim’s underlying design philosophy: we’re more likely to edit text on the command line than we are to write it). To insert text in your document, switch to Insert mode by pressing i. You can check whether you’re in Insert mode by looking at the bottom left hand portion of the window, which should read -- INSERT --. Once you are done inserting text, pressing ESC (the Escape key) will bring you back to Normal mode. From here, you can save and quit your file, though these actions differ from other text editors and word processors: saving and quitting with Vim works through a sequence of key commands (or chords), which you enter from Normal mode. To save a file in Vim, make sure you are in Normal mode and then enter :w. Note the colon, which must be included.After you’ve entered this key sequence, in the bottom left hand corner of your window you should see “[file name] XL, XC written” (L stands for “lines” and C stands for “characters”). To quit Vim, enter :q. This should take you back to your command line and, if you have created a new file, you will now see that file in your window. If you don’t want to save the changes you’ve made in a file, you can toss them out by typing :q! in place of :w and then :q. Also, in Vim key sequences for save, quit, and hundreds of other commands can be chained together. For example, instead of separately inputting :w and :q to save and quit a file, you can use :wq, which will produce the same effect. There are dozens of base commands like this in Vim, and the program can be customized far beyond what you’ll typically need for basic command line usage. More information about this text editor can be found here. 5.2 Basic Vim Commands Table 3.1: Command Function ESC Enter Normal mode. i Enter Insert mdoe. :w Save. :q Quit. :q! Quit without saving. For a more complete list of Vim commands, see this Cheat Sheet. "]]
