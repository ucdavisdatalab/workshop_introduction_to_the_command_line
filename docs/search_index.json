[["index.html", "Introduction to the Unix Command Line Overview", " Introduction to the Unix Command Line Tyler Shoemaker Carl Stahmer 2021-10-07 Overview Learn and practice how to talk directly to your computer via the command line. The Unix shell is a powerful tool for using scientific software, working with large datasets, and controlling remote servers. It is primarily used to manage files and run programs, and it allows for automation of repetitive tasks. This workshop is a prerequisite for many of DataLab’s workshops, including Introduction to Version Control with Git, Reproducible Research for Teams with GitHub, and the Remote Computing series. "],["preliminaries.html", "1 Preliminaries 1.1 Interactive Session Information 1.2 About this Reader 1.3 Objectives for this Workshop 1.4 Prerequisites", " 1 Preliminaries This workshop covers the basics of using the Unix command line interface. It is a hybrid workshop. First, independently work through this online tutorial at your own pace. Next, join us for the live interactive session (details below), during which we will learn to interact with the files and file structures of our computers in new ways. 1.1 Interactive Session Information The workshop includes a live, interactive session, to be held via Zoom on Thursday, November 4th from 12-2pm. Zoom login information will be sent to all registered participants via email; reach out to datalab-training@ucdavis.edu the day prior if you received a registration confirmation but have not received your Zoom link. 1.2 About this Reader This reader provides background information that will help participants to better understand the concepts introduced during the interactive session. It also includes information to help you successfully install software for the workshop, which must be completed prior to the interactive session (note: software setup is only necessary for Windows users). 1.3 Objectives for this Workshop By the end of the workshop, learners should be able to: Explain the directory structure of their computers Navigate across and within files and directories Create, copy, move, and delete files Use command line tools to edit files Identify where to go for help and to learn more 1.4 Prerequisites No prior coding experience is required for this workshop. Participants should have a computer with a Unix shell scripting program (Terminal, Bash, etc.) installed and the latest version of Zoom. Windows users will need to install a Unix terminal ahead of the session. Instructions for doing so are on the following page. "],["installing-a-command-line-interface.html", "2 Installing a Command Line Interface 2.1 Windows Subsystem for Linux 2.2 Enabling the Windows Subsystem for Linux", " 2 Installing a Command Line Interface The following instructions are for Windows users only. Mac and Linux both come pre-installed with Unix-ready command line interfaces, whereas Windows does not. Interested to know why? This article offers a nice overview of the history of different operating systems. 2.1 Windows Subsystem for Linux If you’re on Windows, you’ll need to enable the Windows Subsystem for Linux (WSL) and install Ubuntu, which is available through the Windows Store. WSL/Ubuntu provides a small, Linux-based operating system on your computer, which gives you a full-featured Linux environment that can interact with your normal files. 2.2 Enabling the Windows Subsystem for Linux The DataLab has a short, 10-minute tutorial on setting up a WSL on a Windows computer. It walks through some brief configuration options and then shows you how to get Ubuntu. You can find this tutorial at the DataLab Install Guides page. Under “1. Command Line Tools,” you’ll want to skip down to 1.2: “Linux Subsystem for Windows (Ubuntu).” If you are not able to successfully install the WSL on your own machine, please attend DataLab’s Virtual Office Hours. Click here for more information and to receive a Zoom link. "],["interacting-with-our-computers-a-very-brief-primer.html", "3 Interacting with Our Computers: A Very Brief Primer 3.1 To the Command Line: A Mentality Shift", " 3 Interacting with Our Computers: A Very Brief Primer Most people interact with their computer through a graphical user interface, or GUI, which allows them to use a mouse, keyboard, and graphical elements on screen (such as file menus, pictures of folders and files, etc.) as they do their work. We tend to conflate our operating systems and their GUIs because computer hardware and software manufacturers tightly pack these two things together as a convenience to users. But the operating system that makes your computer work (Windows 10, Mac Big Sur, etc.) and the GUI that you interact with are, in fact, completely different and separable software packages. It is possible to use different methods/software, or shells, to interact with your computer other than the stock GUI that launches automatically when you turn it on. On such method is the “command line” interface (CLI). The command line offers a text-only, non-graphical means of interacting with your computer, acting somewhat like a typewriter (rather than a window or desktop, as the prevailing metaphors for GUIs go). In the early days of computing, all user interaction with your computer happened at the command line. But during the 1980s, computer manufacturers—with Apple at the lead—made a big push to convert their machines to the windowing systems we know today. A CLI, they felt, was too difficult for to understand and this, in turn, would hamper computer sales. Nowadays there are few viable (and at present, almost no commercially available) shells that can compete with the predominant systems of Macs and PCs. While this is less the case for Linux machines, people are by and large locked into the GUIs that come pre-installed on their machines. CLIs are, however, available, and some are even installed on popular computer hardware. 3.1 To the Command Line: A Mentality Shift The following sections will discuss how to open and use CLIs. Doing so is necessarily action-oriented: the workshop covers a host of different commands that will help you in your day-to-day work on a computer. But knowing the pragmatics of using a CLI is only one part of a broader change in the mentality we bring to interacting with our computers beyond the GUI. When we work on the command line, we find ourselves doing things computers typically do for us. Because of this, we need to know more about how our computers work than we would if we only used a GUI. This workshop only covers a small part of that knowledge, but the commands and conventions we’ll discuss tend to generalize to other activities like writing code or tracking files with version control. Learning this material, then, is in part about preparing yourself to learn more advanced computing skills later on. As such, this workshop – and with it, our live session – will cover broader concepts and conventions in computing as much as it will show you how to use the command line. "],["command-line-basics.html", "4 Command Line Basics 4.1 The Anatomy of the Command Line 4.2 Interacting with the Command Line 4.3 Command Syntax 4.4 Common Command Line Commands (and More!) 4.5 When Problems Arise", " 4 Command Line Basics To use the command line, we need to launch a special program. Mac users will use an application called “Terminal,” which ships by default on macOS. To launch Terminal, go to: Applications -&gt; Utilities -&gt; Terminal When you launch the application, you will see something like this: Windows users will use WSL and Ubuntu. Instructions for installing this program are in the second section of this workshop reader. To launch WSL/Ubuntu, go to: Click on the Windows Start Menu and search for “Ubuntu” Alternatively, Click on the Windows Start Menu, select Programs, and browse to Ubuntu When you launch the application, you will see something like this: 4.1 The Anatomy of the Command Line While the command line can look intimidating to those raised on a GUI, it’s important to know that both of the programs above are interfaces in the same way that your computer’s default windowing system is an interface. That is, even though a CLI is something of a bare bones representation of your computer, it too relies on a series of assumptions and metaphors that serve to frame how you interact with your computer. Using the CLI may feel strange at first, but part of that feeling comes from not being acclimated to the way it represents a computer. For example, instead of pointing and clicking on things in your computer, as you’d do with a GUI, you type in your commands with a CLI. In this way, a CLI is more like a typewriter than it is a desktop (an even better analogue would be a teleprinter). To see this, let’s return to the window that opens when you start Terminal or Ubuntu. Everything that will happen in this window happens on a line-by-line basis. Here, we see the command line prompt, where you’ll type your commands. The prompt itself offers valuable information about your computer. The beginning of the line, tshoe@ds, tells us the current user (tshoe) and current computer (ds). This may seem redundant, but with the command line it is possible to interact with remote computers via a network, so it can be helpful to have this information displayed as a reference point. The bit of information after the colon (in this example, the ~ character) tells us where in the computer’s filesystem we are. We’ll discuss this later. For now, just keep in mind that you can look here to find your current location. In this case, ~ means you are in your home directory. After the location, we see the $ character. It is an indicator that lets you know the command line application is waiting for you to enter something. (Note that you do not need to type this character, it will appear automatically, but the examples below include it to emulate what you’ll see onscreen) Depending on your system and/or command line interface, you may or may not also see a solid or flashing box that appears after the prompt character. This is a cursor position indicator and it tells you where the current cursor is in the terminal. This is useful if you need to go back and correct and error. Since you can’t click around with a mouse in a CLI, you’ll have to use your computer’s Left and Right arrows to move the cursor to your desired location and make any changes from there. 4.2 Interacting with the Command Line Now we can enter some commands, which is simply a matter of typing them in after the prompt. For example: $ echo …will print back to screen any text that you supply to the command. It literally echoes your text: $ echo &quot;Hello world!&quot; Hello world! $ To execute this, or any command, you simply hit the Return/Enter key on your keyboard. You’ll see that when you execute a command, the system will perform the indicated operation, print any output from that operation to screen, and deliver a new command line prompt. If you want to see what files and folders are in your home directory, you can use ls (“list”): $ ls backups data.csv jupyter_notebook.ipynb project_folder $ Want some more information about those files and folders? You can modify the base functionality of the ls command – and in fact you can do this for many such commands – with a flag. We do this by adding a dash (-) and then a letter, or a combination of letters. ls -lh …will print out information about the permissions, size, and date of directory contents, as well as the user(s) who created them: $ ls -lh drwxrwxr-x 2 tshoe tshoe 4.0K Jun 21 23:30 backups -rw-rw-r-- 1 tshoe tshoe 28K Oct 4 20:42 data.csv -rw-rw-r-- 1 tshoe tshoe 6.2K Aug 27 22:44 jupyter_notebook.ipynb drwxrwxr-x 8 tshoe tshoe 4.0K Oct 4 21:44 project_folder Depending on your particular system and/or command line interface, things might look slightly different on your computer. However, the basic presentation and functionality as described above will be the same. Typing is the predominant way of using a CLI, and the results of sending in commands with a CLI are text-only representations of your computer and your files. 4.3 Command Syntax As you can see, the syntax of commands is straightforward. Commands use a space to delimit their different components, and flags are called with - to modify those commands. When put together, we can generalize these components look like so: $ [command] [optional flags] [file, data, or other pointer on which to run the command] There is one caveat to this: because commands use spaces to delimit their components, you can run into problems when running commands on files with spaces in their names. Your command line interface program will interpret that file’s spaces as separate components and an error will almost surely result. If you’re running a command on a file with a space in its name, you’ll need to escape that space with \\. This will throw an error: $ [command] file name.txt This will not: $ [command] file\\ name.txt While escape characters are perfectly workable, they can be a bit of a pain to type over and over. For this reason, people who use the command line in their daily work often avoid spaces altogether when naming their files. If you’re interested to learn more about what conventions you might use in place of spaces, see this section on file names in the DataLab’s workshop reader about project organization and documentation. 4.4 Common Command Line Commands (and More!) During our hands-on workshop session we will practice using several commands, which are listed below. Table 4.1: Command Command Name Function ls List Lists all files in the current directory. ls -l List with Long flag Lists additional information about each file. ls -a List with All flag Lists all files, including hidden files. pwd Print Working Directory Prints the current working directory. mkdir Make Directory Creates a new file directory. cd Change Directory Navigates to another directory on the file system. mv Move Moves files. cp Copy Copies files. rm Remove/delete Deletes files. man Manual Opens the manual page for another command. A more complete list of Unix Commands may be found on the Unix Cheat Sheet. That said, there are dozens of base commands, each with their own set of flags, and it’s possible to install software that will expand that number even more. We can’t go over everything in the workshop, but familiarizing yourself with the basic command syntax will help you find your way around new commands. One other thing that will help you learn about new commands is man (“manual”). This opens the manual page for another command: $ man ls …opens: LS(1) User Commands LS(1) NAME ls - list directory contents SYNOPSIS ls [OPTION]... [FILE]... DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE with -l, scale sizes by SIZE when printing them; e.g., &#39;--block-size=M&#39;; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first -C list entries by columns --color[=WHEN] colorize the output; WHEN can be &#39;always&#39; (default if omitted), &#39;auto&#39;, or &#39;never&#39;; more info below -d, --directory list directories themselves, not their contents [...] As opposed to the usually mute, minimalist disposition of a CLI, here you can see thorough documentation for a given command and its various flags. A visually condensed version of this information is also accessible by flagging a command with --help, as in ls --help. Sometimes it can also be helpful to know what version of a command you’re using, as commands themselves can be updated. You can find this information for some commands with --version, or --v: $ man --v man, version 1.6g Still unclear about what a command does? Look it up with your favorite search engine, or visit Stack Exchange and search there. CLIs are widely used software, and chances are incredibly good that someone else has had the same question you want to ask. 4.5 When Problems Arise Error messages offer another, admittedly less pleasant way to learn about how a command works. When you’re first starting out with any kind of console-based software (whether it be a CLI or writing code), one of the most important skills you can learn is how to read an error message. For the most part, such messages are quite clear; they’re intended to help you debug your problem and thus attempt to supply you with information about what might be going wrong. As an example, if you’re at your home directory, and it looks like the following: $ ls backups data.csv jupyter_notebook.ipynb project_folder …and you decide to ls a folder within this directory that doesn’t exist: $ ls no_name You’ll see this error message: $ ls no_name ls: cannot access &#39;no_name&#39;: No such file or directory This tells you that, while you’ve sent in a valid ls command, it can’t find what you’re looking for. Likewise, forgetting a space: $ echo&quot;hello&quot; …will produce: $ echo&quot;hello&quot; zsh: command not found: echohello Or in other words, you’ve sent in a command that’s either invalid or is unavailable. These messages are both fairly clear, but if you’re ever confused, or if you simply want to find out more about an error, a search engine is once again your friend. Sometimes simply copy/pasting the error message and searching on that alone will lead directly to information about what went wrong. That all said, sometimes you need to stop a CLI process immediately. Did you, for example, do something that causes your computer to print a million lines on screen? Did you decide you don’t want a file copied to a new location, and it’s still in the midst of transferring? You can interrupt any command with CTRL+C. This will stop whatever current process is running in your interface. While you can stop a command, for the most part it isn’t possible to undo a command. Please take care to know exactly what you’re running and what you’re running it on, especially when it comes to modifying or deleting things on your computer. "],["navigation.html", "5 Navigation 5.1 File Paths 5.2 Path Hierarchies 5.3 Absolute vs. Relative Paths 5.4 Moving Data Around", " 5 Navigation Due to the nature of its stripped down display, the command line interface can at times feel a bit static. But it offers much of the same functionality that modern GUIs offer, including the ability to move around your computer. With GUIs, we tend to navigate with our mouses; on the command line, we’ll use our keyboard. The live workshop session will cover this in depth, but for now it’s important to have a working sense of how your files are structured. 5.1 File Paths Broadly speaking, your computer is comprised of files (chunks of data) and directories (or “folders”). The way your computer organizes this information is called a directory structure. This structure is like a map of all the places you can navigate to you in your computer. Each file has an address on this map, and there is a path that leads to it. When you use a GUI, your computer does the work of determining which path to follow to find the file or folder you’d like to open, but performing the same operation with a CLI requires us to manually specify where we’d like to go. In a Unix environment, we do this with the following syntax: /this/is/a/path/to/your/file.txt This is called a file path. It threads through several different directories to point directly and specifically at your desired file, file.txt. Note: non-Unix environments on Windows will use \\ instead of /. This isn’t as important to know for our workshop, but if you use file paths in other instances it may factor in to the way you write out a path. 5.2 Path Hierarchies Importantly, the structure of your computer’s directory is hierarchical. Directories nest inside one another. Each / in the path above denotes a new “level” within the directory structure. You thus need to have a sense of which directories are “above” or “below” the present file path to navigate with the command line. The top-most directory in your computer is called root. Unix systems denote it with the / character. It’s like the trunk of a tree: every directory in your computer branches off from it. A complication arises from the fact that directories can also branch off from each other. Whenever you make a folder within another folder – or a subdirectory – you’ve created another branch in the tree, one which is at the same time a branch of root and a branch of whatever directory you’re currently in. For example, this is the structure of the practice exercise we’ll be using during our live session: . top of the directory ├── instructions.md file in the top of the directory ├── instructions.pdf &quot;&quot; └── level_1 first subdirectory ├── level_2a a second subdirectory, below level_1 │ ├── 2.txt file in the second subdirectory │ └── extra_file.txt &quot;&quot; ├── level_2b another subdirectory, at the same level as level_2a │ └── level_3 third subdirectory, below level_2a and level_2b │ └── 1.txt file in the third subdirectory └── wrong_name.txt file in first subdirectory As you can see, this can get complicated! When you’re first getting started with the command line, it’s easy to feel a little lost and forget where you are in your computer. We’ll discuss some strategies to help with this in the live session, but know for the moment that the pwd command will always tell you where you are relative to root: $ pwd /here/is/where/you/are/located/in/your/computer 5.3 Absolute vs. Relative Paths The path above begins with /, which, remember, is root. When you see a path that begins with /, it’s showing you the full, or absolute location of a directory or file. No matter where you are in your computer, no matter how deep into a series of subdirectories you may be, if you used this absolute path with a navigation command, you could go straight to the location it indicates. By contrast, a relative path is context-specific. It depends on wherever you are in your computer. Unix uses some shorthand for this: . denotes the current location in your computer; while .. denotes the directory above that location. We can use this shorthand to avoid having to type out the entire path to a file or directory. This is useful if you’re far away from root, or if, in a coding project, you are using files that are encapsulated in a specific directory structure. To continue with the example from above, if you’re at computer: /here/is/where/you/are/located/in/your/computer ^^^^^^^^ And you want to get to located: /here/is/where/you/are/located/in/your/computer ^^^^^^^ You could use an absolute path to get there. To do so, you use the cd (“change directory”) command: $ cd /here/is/where/you/are/located If we were to represent the logic of this path, it would look like so: root └── here │ └── is │ └── where │ └── you │ └── are └─────────────────&gt; └── located └── in └── your └── computer Alternatively, you could use a relative path: $ cd ../../../ …which we could represent like so: root └── here └── is └── where └── you └── are └── located ^ └── in │ └── your │ └── computer └────────────────┘ The relative path would take you three directories up from computer, which, as you can see above, is located (count the names between backslashes). That’s much shorter, but there’s a downside: those .. sequences are pretty hard to read without context, and it’s easy to get confused. Clearly, there can sometimes be a trade-off between using absolute and relative paths, and in the workshop, we’ll talk about how to weigh such options (particularly when first beginning to use the command line). 5.4 Moving Data Around Beyond helping you navigate, file paths also enable you to move information around on your computer. Doing so works very much like the above. To move a file, we use mv, which has the following syntax: $ mv [location/of/file] [location/where/you/want/to/move/the/file] If we’re in a directory that looks like so: $ ls file.txt subdirectory …and we want to move file.txt into subdirectory, we can use: $ mv ./file.txt ./subdirectory/file.txt Note here that we’ve used ./ to specify that file.txt is in the current directory. Note too that we wrote out the full filename of file.txt after subdirectory. If you didn’t write out the full filename after subdirectory or use ./, your CLI is usually smart enough to infer what you meant and would move file.txt to subdirectory: $ mv file.txt subdirectory $ cd subdirectory $ ls file.txt However, it’s better to be as specific as possible so as to ensure you’ve moved your file exactly where you want it. Many a file has gotten lost on computers because of inexact commands. "],["text-editing-with-the-command-line.html", "6 Text Editing with the Command Line 6.1 Plain Text vs. Binary Files 6.2 Accessing Command Line Text Editors 6.3 Basic Vim Commands", " 6 Text Editing with the Command Line Beyond the basic commands and navigation functions we’ve discussed so far, the command line also features the ability to edit files directly, usually by means of a text editor. These editors are similar in nature to Microsoft Word or Mac Pages but they’re much more stripped down and tend to work best with plain text files. These editors are only accessible from the command line and it is important to know how to use them so that you can open, read, and write directly on the command line. 6.1 Plain Text vs. Binary Files Before continuing, we’ll briefly distinguish plain text from binary data. This distinction bears directly on what we can and cannot edit using a text editor. In computing, plain text has multiple fuzzy, interlocking meanings, but generally it refers to some kind of data that is stored in a human readable form, which is to say, it is comprised of a collection of text characters (usually ASCII, but increasingly UTF-8). A common way to store this data is with a .txt file, though code files (.py, .R) and tabular data (.csv) also fall under the heading of plain text. Binary data, on the other hand, is not human-readable. It is not stored in a way that cleanly translates to various alphanumeric characters; rather, it stores data as sequences of 0/1 bits without reference to characters. Often, such representations are used for data storage. Common file types for binary data include ones for images (.jpg, .png), for sound (.mp3), and for various executables (.exe). We should note however that, at base, this distinction is somewhat false, in that all files are ultimately just binary data. The plain text/binary distinction is thus more a matter of how computers represent data: bits in plain text represent characters, while bits in binary files represent some kind of custom data format, which often requires special encoding/decoding protocols to use it. We can see how all this works if we try to open a binary file with an application that doesn’t expect this kind of format. For example, if you open this image: …with a text editor, you’ll see something like this: &lt;89&gt;PNG^M ^Z ^@^@^@^MIHDR^@^@^F&lt;86&gt;^@^@^C&lt;9e&gt;^H^F^@^@^@.¡¢¹^@^@^LliCCPICC Profile^@^@H&lt;89&gt;&lt;95&gt;W^GXSÉ^V&lt;9e&gt;[RIh&lt;81&gt;P¤&lt;84&gt;Þ^DéUJ^H-&lt;82&gt;&lt;80&gt;TÁFH^B %Æ&lt;84&gt; bg]Tpí&quot;&lt;8a&gt;^U]^UQt-&lt;80&gt;,*b/ &lt;8b&gt;bï&lt;8b&gt;^E&lt;95&gt;&lt;95&gt;u± (*oB^Bºî+ß;ß7wþ{æÌ^?Ê&lt;9d&gt;¹÷^N^@Z½&lt;©4^OÕ^F _R K&lt;88&gt;^Le&lt;8d&gt;MKg&lt;91&gt;:^@^Y0^@^S&lt;98&gt;^C?^^_. eÇÇÇ^@(&lt;83&gt;ýßåÝ^M&lt;80&gt;(û«ÎJ®^?&lt;8e&gt;ÿWÑ^U^Hå|^@&lt;90&gt;ñ^Pg [...] A complete mess! We’re seeing this because text editors aren’t able to interpret data streams from binary files. There would be no way to edit this kind of file in a text editor – you’d simply have no idea where to start. And more, making any such changes would likely cause problems in the file data itself, since it contains custom encodings that don’t correspond to plain text characters. If we deleted the output above from this image, resaved it, and reopened it in an image viewer… …we’ll see that it’s been corrupted. If, while working on the command line, you need to get a sense of what kind of data is stored in a file, the file function is useful. Here’s an image: $ file broken_image.png broken_image.png: PNG image data, 520 x 470, 8-bit/color RGBA, non-interlaced That won’t work for us. On the other hand: $ file README.md 01_overview.Rmd: ASCII text …will. The ASCII text message lets us know we can open it with a text editor. The same goes for a .csv: $ file data.csv data.csv: CSV text We would be able to open this as well. 6.2 Accessing Command Line Text Editors To open such files on the command line, we’ll use a text editor called Vim. Macs and WSL/Ubuntu both ship with this application, so no need to download it (other command editors include Emacs and Nano). If you’d like to open a file with vim, type vi in a command line window, followed by the filename. You can also create a new file this way, simply by typing the name you’d like to use for that file after vi. Vim works a bit differently than other text editors and word processors. It has a number of ‘modes,’ which provide different forms of interaction with a file’s data. We will focus on two modes, Normal mode and Insert. When you open a file with Vim, the program starts in Normal mode. This mode is command-based and, somewhat strangely, it doesn’t let you insert text directly in the document (the reasons for this have to do with Vim’s underlying design philosophy: we’re more likely to edit text on the command line than we are to write it). To insert text in your document, switch to Insert mode by pressing i. You can check whether you’re in Insert mode by looking at the bottom left hand portion of the window, which should read -- INSERT --. Once you are done inserting text, pressing ESC (the Escape key) will bring you back to Normal mode. From here, you can save and quit your file, though these actions differ from other text editors and word processors: saving and quitting with Vim works through a sequence of key commands (or chords), which you enter from Normal mode. To save a file in Vim, make sure you are in Normal mode and then enter :w. Note the colon, which must be included.After you’ve entered this key sequence, in the bottom left hand corner of your window you should see “[file name] XL, XC written” (L stands for “lines” and C stands for “characters”). To quit Vim, enter :q. This should take you back to your command line and, if you have created a new file, you will now see that file in your window. If you don’t want to save the changes you’ve made in a file, you can toss them out by typing :q! in place of :w and then :q. Also, in Vim key sequences for save, quit, and hundreds of other commands can be chained together. For example, instead of separately inputting :w and :q to save and quit a file, you can use :wq, which will produce the same effect. There are dozens of base commands like this in Vim, and the program can be customized far beyond what you’ll typically need for basic command line usage. More information about this text editor can be found here. 6.3 Basic Vim Commands Table 4.1: Command Function ESC Enter Normal mode. i Enter Insert mdoe. :w Save. :q Quit. :q! Quit without saving. For a more complete list of Vim commands, see this Cheat Sheet. "]]
